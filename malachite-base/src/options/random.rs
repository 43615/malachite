use bools::random::{weighted_random_bools, WeightedRandomBools};
use random::Seed;

/// Generates random `Option`s, except `None`, with values from a given random iterator.
///
/// This `struct` is created by the `random_somes` function. See its documentation for more.
#[derive(Clone, Debug)]
pub struct RandomSomes<I: Iterator> {
    xs: I,
}

impl<I: Iterator> Iterator for RandomSomes<I> {
    type Item = Option<I::Item>;

    #[inline]
    fn next(&mut self) -> Option<Option<I::Item>> {
        Some(self.xs.next())
    }
}

/// Generates random `Option`s, except `None`, with values from a given random iterator.
///
/// The values have the same distribution as the values generated by the given iterator: If $Q(x)$
/// is the probability of $x$ being generated by `xs`, then
///
/// $P(\operatorname{Some}(x)) = Q(x)$.
///
/// `xs` must be infinite.
///
/// The output length is infinite.
///
/// # Expected complexity per iteration
/// Same as the time and additional memory complexity of iterating `xs`.
///
/// # Examples
/// ```
/// extern crate itertools;
///
/// use itertools::Itertools;
///
/// use malachite_base::num::random::random_primitive_ints;
/// use malachite_base::options::random::random_somes;
/// use malachite_base::random::EXAMPLE_SEED;
///
/// assert_eq!(
///     random_somes(random_primitive_ints::<u8>(EXAMPLE_SEED)).take(5).collect_vec(),
///     &[Some(113), Some(239), Some(69), Some(108), Some(228)],
/// )
/// ```
pub fn random_somes<I: Iterator>(xs: I) -> RandomSomes<I> {
    RandomSomes { xs }
}

/// Generates random `Option`s with values from a given random iterator.
///
/// We don't use `WithSpecialValue` here because that requires `I::Item` to be cloneable. The
/// "special value" in this case, `None`, can be produced on demand without any cloning.
///
/// This `struct` is created by the `random_options` function. See its documentation for more.
#[derive(Clone, Debug)]
pub struct RandomOptions<I: Iterator> {
    bs: WeightedRandomBools,
    xs: I,
}

impl<I: Iterator> Iterator for RandomOptions<I> {
    type Item = Option<I::Item>;

    #[inline]
    fn next(&mut self) -> Option<Option<I::Item>> {
        Some(if self.bs.next().unwrap() {
            self.xs.next()
        } else {
            None
        })
    }
}

/// Generates random `Option`s with values from a given random iterator.
///
/// The probability of generating `None` is specified by a $p$ =
/// `none_p_numerator` / `none_p_denominator`. If a `Some` is generated, its values have the same
/// distribution as the values generated by the given iterator.
///
/// If $Q(x)$ is the probability of $x$ being generated by `xs`, then
///
/// $P(\text{None}) = p$
///
/// $P(\operatorname{Some}(x)) = (1-p)\frac{Q(x)}$
///
/// `xs` must be infinite.
///
/// The output length is infinite.
///
/// # Expected worst-case complexity
///
/// Same as the time and additional memory complexity of iterating `xs`.
///
/// # Panics
/// Panics if `none_p_denominator` is 0 or `none_p_numerator` > `none_p_denominator`.
///
/// # Examples
/// ```
/// extern crate itertools;
///
/// use itertools::Itertools;
///
/// use malachite_base::num::random::random_primitive_ints;
/// use malachite_base::options::random::random_options;
/// use malachite_base::random::EXAMPLE_SEED;
///
/// assert_eq!(
///     random_options(EXAMPLE_SEED, 1, 2, &random_primitive_ints::<u8>).take(10).collect_vec(),
///     &[
///         Some(85), Some(11), Some(136), None, Some(200), None, Some(235), Some(134), Some(203),
///         None
///     ],
/// )
/// ```
pub fn random_options<I: Iterator>(
    seed: Seed,
    none_p_numerator: u64,
    none_p_denominator: u64,
    xs_gen: &dyn Fn(Seed) -> I,
) -> RandomOptions<I> {
    RandomOptions {
        bs: weighted_random_bools(
            seed.fork("bs"),
            none_p_denominator - none_p_numerator,
            none_p_denominator,
        ),
        xs: xs_gen(seed.fork("xs")),
    }
}
