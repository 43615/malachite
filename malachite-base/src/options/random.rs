use bools::random::{weighted_random_bools, WeightedRandomBools};
use random::Seed;

/// Generates random `Option`s, except `None`, with values from a given random iterator.
///
/// This `struct` is created by the `random_somes` method. See its documentation for more.
#[derive(Clone, Debug)]
pub struct RandomSomes<I: Iterator> {
    xs: I,
}

impl<I: Iterator> Iterator for RandomSomes<I> {
    type Item = Option<I::Item>;

    #[inline]
    fn next(&mut self) -> Option<Option<I::Item>> {
        Some(self.xs.next())
    }
}

/// Generates random `Option`s, except `None`, with values from a given random iterator.
///
/// The values have the same distribution as the values generated by the given iterator: If $Q(x)$
/// is the probability of $x$ being generated by `xs`, then
///
/// $P(\operatorname{Some}(x)) = Q(x)$.
///
/// `xs` must be infinite.
///
/// The output length is infinite.
///
/// # Expected complexity per iteration
///
/// Same as the time and additional memory complexity of iterating `xs`.
///
/// # Examples
/// ```
/// use malachite_base::num::random::random_primitive_ints;
/// use malachite_base::options::random::random_somes;
/// use malachite_base::random::EXAMPLE_SEED;
///
/// assert_eq!(
///     random_somes(random_primitive_ints::<u8>(EXAMPLE_SEED)).take(5).collect::<Vec<_>>(),
///     &[Some(113), Some(239), Some(69), Some(108), Some(228)],
/// )
/// ```
pub fn random_somes<I: Iterator>(xs: I) -> RandomSomes<I> {
    RandomSomes { xs }
}

/// Generates random `Option`s with values from a given random iterator.
///
/// This `struct` is created by the `random_options` method. See its documentation for more.
#[derive(Clone, Debug)]
pub struct RandomOptions<I: Iterator> {
    bs: WeightedRandomBools,
    xs: I,
}

impl<I: Iterator> Iterator for RandomOptions<I> {
    type Item = Option<I::Item>;

    #[inline]
    fn next(&mut self) -> Option<Option<I::Item>> {
        Some(if self.bs.next().unwrap() {
            self.xs.next()
        } else {
            None
        })
    }
}

/// Generates random `Option`s with values from a given random iterator.
///
/// The relative probabilities of generating `None` and `Some` are specified by a weight $w$ =
/// `w_numerator` / `w_denominator`, with `None` being $w$ times more likely to appear than any
/// `Some`. So when $w=1$ the probabilities of `None` and `Some` are equal, when $w>1$ `None` is
/// more likely, and when $w<1$ `Some` is more likely. If a `Some` is generated, its values have the
/// same distribution as the values generated by the given iterator.
///
/// If $Q(x)$ is the probability of $x$ being generated by `xs`, then
///
/// $P(\text{None}) = \frac{w}{w+1}$
///
/// $P(\operatorname{Some}(x)) = \frac{Q(x)}{w+1}$
///
/// `xs` must be infinite.
///
/// The output length is infinite.
///
/// # Expected complexity per iteration
///
/// Same as the time and additional memory complexity of iterating `xs`.
///
/// # Examples
/// ```
/// use malachite_base::num::random::random_primitive_ints;
/// use malachite_base::options::random::random_options;
/// use malachite_base::random::EXAMPLE_SEED;
///
/// assert_eq!(
///     random_options(EXAMPLE_SEED, random_primitive_ints::<u8>(EXAMPLE_SEED.fork("xs")), 1, 1)
///         .take(10).collect::<Vec<_>>(),
///     &[None, Some(85), Some(11), Some(136), None, None, None, Some(200), None, None],
/// )
/// ```
pub fn random_options<I: Iterator>(
    seed: Seed,
    xs: I,
    w_numerator: u64,
    w_denominator: u64,
) -> RandomOptions<I> {
    RandomOptions {
        bs: weighted_random_bools(seed, w_numerator, w_denominator),
        xs,
    }
}
