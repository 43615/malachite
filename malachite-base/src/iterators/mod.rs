use std::collections::HashSet;
use std::hash::Hash;

use itertools::Itertools;

use num::basic::traits::Zero;

/// Generates all the nonzero values of a provided iterator.
///
/// This `struct` is created by the `nonzero_values` function. See its documentation for more.
#[derive(Clone, Debug)]
pub struct NonzeroValues<I: Iterator>(I)
where
    I::Item: Eq + Zero;

impl<I: Iterator> Iterator for NonzeroValues<I>
where
    I::Item: Eq + Zero,
{
    type Item = I::Item;

    #[inline]
    fn next(&mut self) -> Option<I::Item> {
        loop {
            let x = self.0.next();
            if x != Some(I::Item::ZERO) {
                return x;
            }
        }
    }
}

/// Returns an iterator that generates all the nonzero values of a provided iterator.
///
/// `nonzero_values(xs)` generates the same values as `xs.filter(|x| x != T::ZERO)`, but its type is
/// easier to work with.
///
/// This iterator will hang if given an iterator that produces an infinite suffix of zeros.
///
/// The output length is the number of nonzero values produced by `xs`.
///
/// # Examples
/// ```
/// use malachite_base::iterators::nonzero_values;
///
/// assert_eq!(
///     nonzero_values([-3i8, -2, -1, 0, 1, 2, 3].iter().cloned()).collect::<Vec<_>>(),
///     &[-3, -2, -1, 1, 2, 3]
/// )
/// ```
#[inline]
pub fn nonzero_values<I: Iterator>(xs: I) -> NonzeroValues<I>
where
    I::Item: Eq + Zero,
{
    NonzeroValues(xs)
}

/// Returns whether all of the values generated by an iterator are equal.
///
/// `is_constant(xs)` is equivalent to `xs.unique().count() == 1` for finite iterators, but is more
/// efficient, doesn't require `Clone` or `Hash` implementations, and doesn't hang if provided an
/// infinite non-constant iterator.
///
/// This function will hang if given an infinite constant iterator.
///
/// # Worst-case complexity
/// $T(n) = O(n)$
///
/// $M(n) = O(1)$
///
/// where $T$ is time, $M$ is additional memory, and $n$ is the number of values produced by `xs`.
///
/// # Examples
/// ```
/// use malachite_base::iterators::is_constant;
///
/// assert_eq!(is_constant([1; 4].iter()), true);
/// assert_eq!(is_constant([1, 2, 3, 4].iter()), false);
/// ```
pub fn is_constant<I: Iterator>(xs: I) -> bool
where
    I::Item: Eq,
{
    let mut first = None;
    for x in xs {
        if let Some(ref first) = first {
            if x != *first {
                return false;
            }
        } else {
            first = Some(x);
        }
    }
    true
}

/// Returns whether an iterator returns at least some number of values.
///
/// `count_is_at_least(xs, n)` is equivalent to `xs.count() >= n` for finite iterators, but doesn't
/// hang if provided an infinite iterator.
///
/// # Worst-case complexity
/// $T(n) = O(n)$
///
/// $M(n) = O(1)$
///
/// where $T$ is time, $M$ is additional memory, and $n$ is `min(n, xs.count())`.
///
/// # Examples
/// ```
/// use malachite_base::iterators::count_is_at_least;
///
/// assert_eq!(count_is_at_least([1, 2, 3, 4].iter(), 3), true);
/// assert_eq!(count_is_at_least([1, 2, 3, 4].iter(), 4), true);
/// assert_eq!(count_is_at_least([1, 2, 3, 4].iter(), 5), false);
/// ```
#[inline]
pub fn count_is_at_least<I: Iterator>(xs: I, n: usize) -> bool {
    xs.take(n).count() == n
}

/// Returns whether an iterator returns at most some number of values.
///
/// `count_is_at_most(xs, n)` is equivalent to `xs.count() <= n` for finite iterators, but doesn't
/// hang if provided an infinite iterator.
///
/// # Worst-case complexity
/// $T(n) = O(n)$
///
/// $M(n) = O(1)$
///
/// where $T$ is time, $M$ is additional memory, and $n$ is `min(n, xs.count())`.
///
/// # Examples
/// ```
/// use malachite_base::iterators::count_is_at_most;
///
/// assert_eq!(count_is_at_most([1, 2, 3, 4].iter(), 3), false);
/// assert_eq!(count_is_at_most([1, 2, 3, 4].iter(), 4), true);
/// assert_eq!(count_is_at_most([1, 2, 3, 4].iter(), 5), true);
/// ```
#[inline]
pub fn count_is_at_most<I: Iterator>(xs: I, n: usize) -> bool {
    xs.take(n + 1).count() <= n
}

/// Returns whether an iterator never returns the same value twice.
///
/// `is_unique(xs)` is equivalent to `xs.unique().count() <= 1` for finite iterators, but is more
/// efficient and doesn't hang if provided a non-unique infinite iterator.
///
/// This iterator will hang if given an infinite unique iterator.
///
/// # Worst-case complexity
/// $T(n) = O(n)$
///
/// $M(n) = O(n)$
///
/// where $T$ is time, $M$ is additional memory, and $n$ is `xs.count()`.
///
/// # Examples
/// ```
/// use malachite_base::iterators::is_unique;
///
/// let empty: [u32; 0] = [];
/// assert_eq!(is_unique(empty.iter()), true);
/// assert_eq!(is_unique([1, 2, 3, 4].iter()), true);
/// assert_eq!(is_unique([1, 2, 3, 1].iter()), false);
/// ```
#[inline]
pub fn is_unique<I: Iterator>(xs: I) -> bool
where
    I::Item: Clone + Eq + Hash,
{
    let mut set = HashSet::new();
    for x in xs {
        if !set.insert(x) {
            return false;
        }
    }
    true
}

/// Returns the first and last elements of an iterator, or `None` if it is empty.
///
/// The iterator's elements must be cloneable, since if the iterator consists of a single element
/// `x`, the result will be `(x, x)`.
///
/// This iterator will hang if given an infinite iterator.
///
/// # Worst-case complexity
/// $T(n) = O(n)$
///
/// $M(n) = O(1)$
///
/// where $T$ is time, $M$ is additional memory, and $n$ is `xs.count()`.
///
/// # Examples
/// ```
/// use malachite_base::iterators::first_and_last;
///
/// let empty: [u32; 0] = [];
/// assert_eq!(first_and_last(&mut empty.iter()), None);
/// assert_eq!(first_and_last(&mut [1].iter().cloned()), Some((1, 1)));
/// assert_eq!(first_and_last(&mut [1, 2, 3].iter().cloned()), Some((1, 3)));
/// ```
pub fn first_and_last<I: Iterator>(xs: &mut I) -> Option<(I::Item, I::Item)>
where
    I::Item: Clone,
{
    xs.next().map(|first| {
        if let Some(last) = xs.last() {
            (first, last)
        } else {
            (first.clone(), first)
        }
    })
}

/// Groups elements of an iterator into intervals of adjacent elements that match a predicate.
///
/// The intervals are inclusive.
///
/// This iterator will hang if given an infinite iterator.
///
/// # Worst-case complexity
/// $T(n) = O(n)$
///
/// $M(n) = O(n)$
///
/// where $T$ is time, $M$ is additional memory, and $n$ is `xs.count()`.
///
/// # Examples
/// ```
/// use malachite_base::iterators::matching_intervals_in_iterator;
///
/// let xs = &[1, 2, 10, 11, 12, 7, 8, 16, 5];
/// assert_eq!(
///     matching_intervals_in_iterator(xs.iter().cloned(), |&x| x >= 10).as_slice(),
///     &[(10, 12), (16, 16)]
/// );
/// assert_eq!(
///     matching_intervals_in_iterator(xs.iter().cloned(), |&x| x < 10).as_slice(),
///     &[(1, 2), (7, 8), (5, 5)]
/// );
/// ```
pub fn matching_intervals_in_iterator<I: Iterator, F: Fn(&I::Item) -> bool>(
    xs: I,
    predicate: F,
) -> Vec<(I::Item, I::Item)>
where
    I::Item: Clone,
{
    xs.group_by(predicate)
        .into_iter()
        .filter_map(|(b, mut group)| if b { first_and_last(&mut group) } else { None })
        .collect()
}

/// This module contains `BitDistributor`, which helps generate tuples exhaustively.
pub mod bit_distributor;
/// This module contains functions that compare adjacent iterator elements.
pub mod comparison;
/// This module defines `IteratorCache`, which remembers values produced by an iterator.
pub mod iterator_cache;
