use malachite_base::num::basic::floats::PrimitiveFloat;
use malachite_base::num::float::NiceFloat;
use malachite_base_test_util::generators::primitive_float_gen_var_8;
use malachite_q::Rational;
use malachite_q_test_util::generators::rational_gen_var_7;

#[test]
fn test_from_f32_simplest() {
    let test = |f: f32, out| {
        let x = Rational::from_float_simplest(f);
        assert_eq!(x.to_string(), out);
        assert!(x.is_valid());
    };
    test(0.0, "0");
    test(-0.0, "0");
    test(123.0, "123");
    test(-123.0, "-123");
    test(1.0e9, "1000000000");
    test(-1.0e9, "-1000000000");
    test(4294967295.0, "4294967296");
    test(-4294967295.0, "-4294967296");
    test(4294967296.0, "4294967296");
    test(-4294967296.0, "-4294967296");
    test(18446744073709551615.0, "18446744073709551616");
    test(-18446744073709551615.0, "-18446744073709551616");
    test(18446744073709551616.0, "18446744073709551616");
    test(-18446744073709551616.0, "-18446744073709551616");
    test(1.0e20, "100000002004087734272");
    test(-1.0e20, "-100000002004087734272");
    test(1.23e20, "122999999650278146048");
    test(-1.23e20, "-122999999650278146048");
    test(123.1, "1231/10");
    test(-123.1, "-1231/10");
    test(123.9, "1239/10");
    test(-123.9, "-1239/10");
    test(123.5, "247/2");
    test(-123.5, "-247/2");
    test(124.5, "249/2");
    test(-124.5, "-249/2");
    test(-0.499, "-499/1000");
    test(-0.5, "-1/2");
    test(
        f32::MIN_POSITIVE_SUBNORMAL,
        "1/475749230901986627019428656483165045460915542",
    );
    test(
        -f32::MIN_POSITIVE_SUBNORMAL,
        "-1/475749230901986627019428656483165045460915542",
    );
    test(
        f32::MAX_SUBNORMAL,
        "1/85070596800837319010234175901631774785",
    );
    test(
        -f32::MAX_SUBNORMAL,
        "-1/85070596800837319010234175901631774785",
    );
    test(
        f32::MIN_POSITIVE_NORMAL,
        "1/85070586659632517184362935130987167681",
    );
    test(
        -f32::MIN_POSITIVE_NORMAL,
        "-1/85070586659632517184362935130987167681",
    );
    test(f32::MAX_FINITE, "340282346638528859811704183484516925440");
    test(-f32::MAX_FINITE, "-340282346638528859811704183484516925440");

    test(std::f32::consts::SQRT_2, "4756/3363");
    test(std::f32::consts::PI, "93343/29712");
    test(std::f32::consts::E, "2721/1001");

    test(0.33333334, "1/3");
    test(0.3333333, "3195660/9586981");
}

#[test]
#[should_panic]
fn from_f32_simplest_fail_1() {
    Rational::from_float_simplest(f32::NAN);
}

#[test]
#[should_panic]
fn from_f32_simplest_fail_2() {
    Rational::from_float_simplest(f32::POSITIVE_INFINITY);
}

#[test]
#[should_panic]
fn from_f32_fail_3() {
    Rational::from_float_simplest(f32::NEGATIVE_INFINITY);
}

#[test]
fn test_from_f64_simplest() {
    let test = |f: f64, out| {
        let x = Rational::from_float_simplest(f);
        assert_eq!(x.to_string(), out);
        assert!(x.is_valid());
    };
    test(0.0, "0");
    test(-0.0, "0");
    test(123.0, "123");
    test(-123.0, "-123");
    test(1.0e9, "1000000000");
    test(-1.0e9, "-1000000000");
    test(4294967295.0, "4294967295");
    test(-4294967295.0, "-4294967295");
    test(4294967296.0, "4294967296");
    test(-4294967296.0, "-4294967296");
    test(18446744073709551615.0, "18446744073709551616");
    test(-18446744073709551615.0, "-18446744073709551616");
    test(18446744073709551616.0, "18446744073709551616");
    test(-18446744073709551616.0, "-18446744073709551616");
    test(1.0e20, "100000000000000000000");
    test(-1.0e20, "-100000000000000000000");
    test(1.23e20, "123000000000000000000");
    test(-1.23e20, "-123000000000000000000");
    test(
        1.0e100,
        "100000000000000001590289110975991804683608085639452813897813275577478387721703810608134699\
        85856815104",
    );
    test(
        -1.0e100,
        "-10000000000000000159028911097599180468360808563945281389781327557747838772170381060813469\
        985856815104",
    );
    test(
        1.23e100,
        "123000000000000008366862950845375853795062237854139353014252897832358837028676639186389822\
        00322686976",
    );
    test(
        -1.23e100,
        "-12300000000000000836686295084537585379506223785413935301425289783235883702867663918638982\
        200322686976",
    );
    test(123.1, "1231/10");
    test(-123.1, "-1231/10");
    test(123.9, "1239/10");
    test(-123.9, "-1239/10");
    test(123.5, "247/2");
    test(-123.5, "-247/2");
    test(124.5, "249/2");
    test(-124.5, "-249/2");
    test(-0.499, "-499/1000");
    test(-0.5, "-1/2");
    test(
        f64::MIN_POSITIVE_SUBNORMAL,
        "1/134934835538207078901663564479278204699704433176094745571267572018286893045330231261306\
        922467624749663458051909544541274259872491590528984578008933293825673281011616184377574242\
        977938494728810894159845118981830045708004988949795132412068903766106370893873371008239179\
        701555609743487001688124218339097337508871805160728996523",
    );
    test(
        -f64::MIN_POSITIVE_SUBNORMAL,
        "-1/13493483553820707890166356447927820469970443317609474557126757201828689304533023126130\
        692246762474966345805190954454127425987249159052898457800893329382567328101161618437757424\
        297793849472881089415984511898183004570800498894979513241206890376610637089387337100823917\
        9701555609743487001688124218339097337508871805160728996523",
    );
    test(
        f64::MAX_SUBNORMAL,
        "1/449423283715579026828334036065257014383474871770369402158895481105061903177076758952991\
        447760350212414247530205607522865754608382719974023705572587637923509973673766132988527495\
        573581641607121816936686895147170329503865639571478615835487722625286251243883901055723066\
        31238281271786009918606677660346752204801",
    );
    test(
        -f64::MAX_SUBNORMAL,
        "-1/44942328371557902682833403606525701438347487177036940215889548110506190317707675895299\
        144776035021241424753020560752286575460838271997402370557258763792350997367376613298852749\
        557358164160712181693668689514717032950386563957147861583548772262528625124388390105572306\
        631238281271786009918606677660346752204801",
    );
    test(
        f64::MIN_POSITIVE_NORMAL,
        "1/449423283715578927036318559329266431564839219927211067229101097246506353572882385286930\
        040496229077692647131520826525095187415228669222594373726590254689108839132120159189741421\
        503549517982068519788656012202297150024869750306233834035420571989467252315767391654946280\
        61906253051009157224240331719237716377601",
    );
    test(
        -f64::MIN_POSITIVE_NORMAL,
        "-1/44942328371557892703631855932926643156483921992721106722910109724650635357288238528693\
        004049622907769264713152082652509518741522866922259437372659025468910883913212015918974142\
        150354951798206851978865601220229715002486975030623383403542057198946725231576739165494628\
        061906253051009157224240331719237716377601",
    );
    test(
        f64::MAX_FINITE,
        "179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558\
        6327668781715404589535143824642343213268894641827684675467035375169860499105765512820762454\
        9009038932894407586850845513394230458323690322294816580855933212334827479782620414472316873\
        8177180919299881250404026184124858368"
    );
    test(
        -f64::MAX_FINITE,
        "-17976931348623157081452742373170435679807056752584499659891747680315726078002853876058955\
        8632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245\
        4900903893289440758685084551339423045832369032229481658085593321233482747978262041447231687\
        38177180919299881250404026184124858368"
    );

    test(std::f64::consts::SQRT_2, "131836323/93222358");
    test(std::f64::consts::PI, "245850922/78256779");
    test(std::f64::consts::E, "268876667/98914198");

    test(0.3333333333333333, "1/3");
    test(0.3333333333333337, "279293000147008/837879000441023");
}

#[test]
#[should_panic]
#[allow(unused_must_use)]
fn from_f64_simplest_fail_1() {
    Rational::from_float_simplest(f64::NAN);
}

#[test]
#[should_panic]
#[allow(unused_must_use)]
fn from_f64_simplest_fail_2() {
    Rational::from_float_simplest(f64::POSITIVE_INFINITY);
}

#[test]
#[should_panic]
#[allow(unused_must_use)]
fn from_f64_simplest_fail_3() {
    Rational::from_float_simplest(f64::NEGATIVE_INFINITY);
}

fn from_float_simplest_properties_helper<
    T: From<Rational> + for<'a> From<&'a Rational> + PrimitiveFloat,
>()
where
    Rational: From<T>,
{
    primitive_float_gen_var_8::<T>().test_properties(|f| {
        let q = Rational::from(f);
        assert!(q.is_valid());
        assert_eq!(Rational::from(-f), -&q);
        assert_eq!(NiceFloat(T::from(q)), NiceFloat(f.abs_negative_zero()));
    });

    rational_gen_var_7().test_properties(|q| {
        // This only works for simple `Rational`s, i.e. those `Rational`s q that round to a float
        // x such that no simpler `Rational` rounds to x.
        assert_eq!(Rational::from_float_simplest(T::from(&q)), q);
    });
}

#[test]
fn from_float_simplest_properties() {
    apply_fn_to_primitive_floats!(from_float_simplest_properties_helper);
}
